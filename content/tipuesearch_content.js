var tipuesearch = {"pages": [{'title': 'About', 'text': '此內容管理系統以\xa0 https://github.com/mdecourse/cmsimde \xa0作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作. \n 利用 cmsimde 建立靜態網誌方法: \n 1. 在 github 建立倉儲, git clone 到近端 \n 2. 參考\xa0 https://github.com/mdecourse/newcms , 加入除了 cmsimde 目錄外的所有內容 \n 以 git submodule add\xa0 https://github.com/mdecourse/cmsimde \xa0cmsimde \n 建立 cmsimde 目錄, 並從 github 取下子模組內容. \n 3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器. \n 動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端. \n 4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行: \n git clone --recurse-submodules  https://github.com/mdecourse/newcms.git \n', 'tags': '', 'url': 'About.html'}, {'title': 'Develop', 'text': 'https://github.com/mdecourse/cmsimde \xa0的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443\xa0就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容. \n cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版. \n init.py 位於\xa0 up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數. \n', 'tags': '', 'url': 'Develop.html'}, {'title': 'Solvespace', 'text': '', 'tags': '', 'url': 'Solvespace.html'}, {'title': 'Tutorial practice', 'text': 'tutorial 1 simple plate \n \n tutorial 2 three-way connector \n \n tutorial_3_ Sketch Rotation around an Axis \n \n tutorial_4_Assembly \n \n tutorial_6_Christmas Tree(BONUS) \n \n tutorial_7_Constrained Movement \n \n tutorial_8_Interactive 3D Model in Browser \n \xa0 \xa0tutorial 11: Cubic Bezier Spline tool (Vase) \n \n \n \n tutorial_9_a Simple Gear \n \n tutorial_10_ Fidget Spinner \n \n tutorial_11_cubic bezier spline tool (vase) \n \n tutorial_12_How to create a Mechanical Linked System \n \n 繪圖驗證1 \n \n 繪圖驗證3 \n \n 繪圖驗證4 \n \n 繪圖認證6 \n \n 繪圖認證7 \n \n 繪圖認證8 \n \n 繪圖認證9 \n \n 繪圖認證10 \n \n 繪圖認證11 \n \n 繪圖認證12 \n \n 繪圖認證13 \n \n 繪圖認證14 \n \n 繪圖認證15 \n \n 繪圖認證16 \n \n 繪圖認證17 \n \n 繪圖驗證18 \n \n \n', 'tags': '', 'url': 'Tutorial practice.html'}, {'title': 'Car model', 'text': '\n 檔案位子:carmodel/carbody.slvs \n 參考圖像: https://www.google.com/search?q=rainbow+six++Unmanned+vehicle&rlz=1C1GCEA_enTW812TW812&sxsrf=ACYBGNRHnkoLe0kouEp3qp6hRlMV8B3EQQ:1571582838834&source=lnms&tbm=isch&sa=X&ved=0ahUKEwjo1d-miqvlAhUryIsBHRXQCT0Q_AUIEigB&biw=871&bih=843#imgrc=_ \n <<<<<<< HEAD \n >>>>>>> bce730699bbf79fca6977ab6b67993bb4e3ee75c \n', 'tags': '', 'url': 'Car model.html'}, {'title': 'Solidworks', 'text': '', 'tags': '', 'url': 'Solidworks.html'}, {'title': '開發起源', 'text': '起初Jon Hirschtick 和 Axel Bichara在創業班中組成一個團隊，他們寫了一個商業企劃，內容是叫做 Premise的 新CAD軟體公司。 \n Premise最初的軟體產品是Design View，是一個二維的繪圖軟體。雖然軟體的開發很成功但是由於市場太小以至於無法蓬勃發展起來，後來就被Computervision公司給收購了。 \n Jon Hirschtick\xa0和 Axel Bichara也到了Computervision的管理團隊待了一陣子，不過後來Axel Bichara待了大約一年就離開回到法國攻讀MBA學位。 \n 1993年8月Jon Hirschtick也離開了Computervision，因為他不知道他下一步該做什麼也覺得他除了經營公司以外應該還有其他的事情可以做。 \n 1994年1月一個創造低成本桌面設計系統基於實體模型技術的想法開始出現，於是Jon Hirschtick組成了一個團隊，成員包括 Bob Zuffante, Scott Harris, Constantine Dokos和Tommy Li，最終發展出 的產品就為Solidworks。 \n', 'tags': '', 'url': '開發起源.html'}, {'title': 'Solidworks 繪圖練習', 'text': '\n', 'tags': '', 'url': 'Solidworks 繪圖練習.html'}, {'title': 'Inventor', 'text': '', 'tags': '', 'url': 'Inventor.html'}, {'title': 'Practice', 'text': '>>>>>>> e57712a9a4b0cd2222e8ab8be05fcaf682d69cd9 \n \n', 'tags': '', 'url': 'Practice.html'}, {'title': 'NX12', 'text': '', 'tags': '', 'url': 'NX12.html'}, {'title': 'NX12繪圖練習', 'text': '\n', 'tags': '', 'url': 'NX12繪圖練習.html'}, {'title': '教材整理', 'text': '', 'tags': '', 'url': '教材整理.html'}, {'title': 'Ch1~2', 'text': '第1章主要介紹CAD/CAM/CAE的定義及本課本其他章的簡介 第2.1章如何打開nx12的文件 第一步打開nx12 第二步如何打開新的文件\u3000使用頂部按鈕打開新的文件 或 選用菜單打開 或 使用"ctrl+n" 然後跳出介面 確認尺寸為毫米 可以改名稱及位置 第三步如何打開新的零件文件\u3000使用頂部按鈕打開新的零件文件 或 選用菜單打開 或 使用"ctrl+ｏ" 第2.2章如何打印，保存和關閉零件文件 打印 File →Print 選擇要使用的打印機或指定編號 打印份數，紙張尺寸等。可以為所有三個選擇比例尺寸。可以選擇通過單擊來打印，即線框實體模型輸出下拉菜單 保存 File →Save  關閉零件文件 File →Close 第2.3章如何使用滑鼠及nx12的介面介紹 第2.4章圖層 第2.5章座標系統 第2.6章工具欄 \n 實際操作影片 \n \n \n', 'tags': '', 'url': 'Ch1~2.html'}, {'title': 'Ch5~6', 'text': '\n 5-1 如何選擇平面與如何視圖 5-2 設定紙張尺寸大小、第幾角法 \n 切換視角與關閉不必要的線條 \n 5-3 尺寸標註 \n 5-4 切換剖視圖 \n 5-5 在實體面標註尺寸 \n \n 5-6 \n 草圖繪製,給予形狀公差 \n \n 6-1 \n 分辨零件、組合件 \n 6-2 \n 使用Top-Down Approach(由上而下的畫法),Bottom-Up Approach(由下而上的畫法) \n 6-3 \n 了解零件如何互相約束 \n 6-4 \n 使用不同的約束 \n 分別為: 對齊;同心;距離;平行;垂直;鍵合;置中;角度 \n \n 6-5,6-6 \n 操作實際例題 \n', 'tags': '', 'url': 'Ch5~6.html'}, {'title': 'Ch7', 'text': 'Ch7\xa0 自由曲面的建模 \n 此章節主要在講述可以利用何種方法來建構曲面 \n 1.利用"點"來建立曲面 \n (1)利用四個點來建立一曲面 \n (2)以矩形點陣列構成的多個點來建立一曲面 \n (3)定義的點形成矩形陣列與穿過它們的線相切 \n ---------------------------------------------------------------------------------- \n 2.利用"線"來建立曲面 \n (1)用兩條大致平行的線 \n (2)3條或以上大致平行的線 \n (3)由至少4條剖面線，且存在至少2條線段方向關係為垂直且平行於面區域 \n (4)由至少2條剖面線且有2條大致垂直的線和2條剖面線有重和關係 \n ---------------------------------------------------------------------------------- \n 3.利用面來建立自由曲面 \n (1)利用原有的曲面來偏移 \n (2)利用原有曲面的面或邊來做延伸的功能 \n', 'tags': '', 'url': 'Ch7.html'}, {'title': 'Ch8', 'text': '第8章－有限元分析 \n Finite Element Analysis (FEA)有限元分析 - 預測結構或流體對應用因素（例如力，壓力，熱量和振動等等 ...) 而本章我們我們重點在於處理實體零件的結構應力和應變分析也就是應力和位移 . \n 8.1.1.\xa0 element(元素/元件)的形狀和節點 \n 元素可分為尺寸 (dimensions) 數和節點 (nodes) 數兩大因素，而這兩大因素則用於分離化(discretization) \n \n', 'tags': '', 'url': 'Ch8.html'}, {'title': 'Ch9', 'text': '第 9 章 \n 此章節在介紹如何使用 NX12 生成用於三軸立式加工中心的 CNC 代碼製造模組，該模組使我們可以對鑽孔，銑削，車削和線切割 EDM 刀具路徑進行編程和一些後續處理。 \n 9-1 入門 \n 創建新檔案 → 設定加工環境 → 操作導航器 ( 註 1)→ 設定機器座標系統 (MCS) → 定義幾何 \n 9-2 創建操作 \n 建立新操作 → 建立新工具並選擇 → 設定工具路徑 → 跨距和 Scallop 高度 ( 註 2)→ 設定每次切削深度 → 設定切削深度 → 設定迴避點 → 調整速度與進給 \n 9-3 生成程序和驗證 \n 生成程序 → 顯示刀具路徑 → 模擬刀具路徑 → 鑿檢驗 ( 註 3) \n 9-4 操作方法 \n 粗加工→半精加工 → 整理零件內外輪廓→精加工外部輪廓 → 精加工內部輪廓 \n 9-5 後期處理 \n 創建 CLSF→ 後期處理 \n \xa0 \n 註 1  “操作導航器”提供有關所創建程序的信息以及有關刀具，方法和策略的相應信息，可以在不同的類別列表中查看程序列表。 \n \xa0 \n 註 2  跨距的大小和刀具直徑將決定每步之間的 Scallop 高度。 減小跨步距離將使 Scallop 高度減低，但需要更多的步幅，因此需要更多的時間來加工特徵。 \n \xa0 \n 註 3  鑿檢驗用於驗證刀具是否確實從工件上去除了多餘的材料。在製造過程有缺陷的零件有兩種可能。一種是去除多餘的材料，另一種是留下應該清除的材料。在大多數情況下，前者更不理想，因為其不可能重新設計。 \n', 'tags': '', 'url': 'Ch9.html'}, {'title': 'Webots', 'text': '<<<<<<< Updated upstream ======= \n >>>>>>> 964fdc740c8f66990d245210f0d18d30016f4138 \n >>>>>>> Stashed changes \n', 'tags': '', 'url': 'Webots.html'}, {'title': 'tutorial', 'text': 'tutorial_1_my_first_simulation \n \n', 'tags': '', 'url': 'tutorial.html'}, {'title': 'W17 協同任務', 'text': 'Building a clean model tutorial \n 40723144、40523241:Building the visible shapes \n 40723153:Building the joints \n 40723138:Building the dynamic shapes \n 40723118、40723132:Model definition \n 40723145:Webots modification of the environment \n 各組員在完成翻譯後自行建立一個h2的標題(以自己學號命名)將自己所做的部分打在裡面 \n <<<<<<< HEAD \n <<<<<<< HEAD \n', 'tags': '', 'url': 'W17 協同任務.html'}, {'title': '40723118', 'text': "In our case, only option 2 is of interest. 在我們的情況下，只有選項2是有意義的。 \n We create a force/torque sensor with [Menu bar --> Add --> Force sensor], then move it to the tip of the robot, then attach it to object robot_link_dyn6. 我們使用[菜單欄->添加->力傳感器]創建一個力/扭矩傳感器，然後將其移動到機器人的尖端，然後將其附加到對象robot_link_dyn6。 \n We change its size and visual appearance appropriately (a red force/torque sensor is often perceived as an optional attachment point, check the various robot models available).We also change its name to robot_attachment: 我們會適當地更改其尺寸和外觀（紅色力/扭矩傳感器通常被視為可選的連接點，請檢查可用的各種機器人型號）。我們還將其名稱更改為robot_attachment： \n \n Now we drag a gripper model into the scene, keep it selected, then control-click the attachment force sensor, then click the \xa0 Assembling/disassembling toolbar button .  The gripper goes into place: 現在，我們將抓手模型拖到場景中，使其保持選中狀態，然後按住Control鍵單擊並單擊附著力傳感器，然後單擊“裝配/拆卸”工具欄按鈕。 夾持器到位： \n \n The gripper knew how to attach itself because it was appropriately configured during its model definition. 抓具知道如何附加自身，因為它在模型定義期間進行了適當的配置。 \n We now also need to properly configure the robot model, so that it will know how to attach itself to a mobile base for instance. 現在，我們還需要正確配置機器人模型，以便它將知道如何將自己附加到移動基座上。 \n We select the robot model, then click Assembling in the \xa0 object common properties . Set an empty string for 'Parent' match values, then click Set matrix.  我們選擇機器人模型，然後在對象公共屬性中單擊“組裝”。為“Parent”匹配值設置一個空字符串，然後單擊“設置矩陣”。 \n This will memorize the current base object's local transformation matrix, and use it to position/orient itself relative to the mobile robot's attachment point. To verify that we did things right, we drag the model Models/robots/mobile/KUKA Omnirob.ttm into the scene. 這將記住當前基礎對象的局部轉換矩陣，並使用它相對於移動機器人的附著點定位/定向。為了驗證我們做的正確，我們將模型Models / robots / mobile / KUKA Omnirob.ttm拖到場景中。 \n Then we select our robot model, then control-click one of the attachment points on the mobile platform, then click the  Assembling/disassembling toolbar button . Our robot should correctly place itself on top of the mobile robot: 然後，我們選擇機器人模型，然後在移動平台上按住Control鍵並單擊其中一個附接點，然後單擊“組裝/拆卸”工具欄按鈕。我們的機器人應該正確地將自己放置在移動機器人的頂部： \n \n Now we could add additional items to our robot, such as sensors for instance. At some point we might also want to attach \xa0 embedded scripts  to our model, in order to control its behaviour or configure it for various purposes. In that case, make sure to understand  how object handles are accessed from embedded scripts . 現在，我們可以向機器人添加其他項目，例如傳感器。在某些時候，我們可能還希望將嵌入式腳本附加到我們的模型中，以便控制其行為或出於各種目的對其進行配置。 在這種情況下，請確保了解如何從嵌入式腳本訪問對象句柄。 \n We can also control/access/interface our model from a  plugin , from a \xa0 remote API  client, from a  ROS  node, from a \xa0 BlueZero  node, or from an  add-on . 我們還可以通過插件，遠程API客戶端，ROS節點，BlueZero節點或附加組件來控制/訪問/接口模型。 \n Now we make sure we have reverted the changes done during robot and gripper attachment, we collapse the hierarchy tree of our robot model, select the base of our model, then save it with [Menu bar --> File --> Save model as...]. If we saved it in the model folder, then the model will be available in the \xa0 model brower . 現在，確保已恢復在機械手和抓爪安裝過程中所做的更改，我們折疊了機械手模型的層次樹，選擇了模型的基礎，然後使用[菜單欄->文件->將模型另存為 ...]。 如果我們將其保存在模型文件夾中，則模型將在模型瀏覽器中可用。 \n \n", 'tags': '', 'url': '40723118.html'}, {'title': '40723145', 'text': 'Webots Tutorial \n Modification of the Environment \n 在這個教材中包含了 1.建立一顆球來跟所建立的環境互動 2.物件中的各個節點的意義和應用 3.設定物理性質 4.利用DEF的功能來避免做重複性的屬性設定 \n 操作步驟: A New Simulation: Hands-on #1 將Webots Tutorial 1 所建立的my_first_simulation.wbt檔案另存一個新的wbt檔 \n Modifying the Floor: 預設的 RectangleArena 是一個靜態的環境(沒有物理性質的節點)而且被牆壁所圍繞，在Wobots物件庫中有多種floor的類型可供選擇 Hands-on #2 先將原本的 RectangleArena 刪除。選取TexturedBackroundLight後再按右鍵選Add，在左方的清單中選取PROTO nodes (Webots Projects) / objects / floors / Floor (Solid)就會加入一個新的floor形式 \n Hands-on #3 在左邊的選單中有一個Floor，拉開他的選單後將size改為1m*1m \n The Solid Node: Solid就是表剛體的意思。在Solid節點中會有各種不同自己要設定的特性，但其中最重要的一點就是在Physics設定中要將物理特性利用Add加入 \n Create a Ball: 在這段中要加入一顆球體，球體的節點中可以更改各種參數 Hands-on #4 1.先選取Solid節點再利用Add功能來加入Shape的節點，在Shape節點中加入球體 2.將metalness數值改為0，roughness數值改為1 3.加入另一個球體節點在boundingObject清單中 4.加入Physics節點在Physics清單中 \n Geometries: Hands-on #5 將球體的半徑改為0.05，subdivision改為2 \n DEF-USE Mechanism: DEF功能可以先將一個物體或是外觀選項做定義的動作，之後在做相同的物體時可以利用DEF功能套用原本的設定 Hands-on #6 1.點選新建的球體後會有一欄DEF的空格，輸入BALL_GEOMETRY 2.選擇boundingObject的區域後將原本的刪除掉 3.選擇boundingObject的區域後利用Add加入USE / BALL_GEOMETRY \n Hands-on #7 建立一個新的球體，利用DEF的功能來設定相同屬性的球體 \n Add Walls: Hands-on #8 加入四面沒有物理特性的牆並使用只有一個定義的Shape節點 \n \n', 'tags': '', 'url': '40723145.html'}, {'title': '40723153', 'text': '接合件 大多數時候，我們知道每個接合件的確切位置和方向。我們只需使用 [Menu bar --> Add --> Joint --> ….]即可添加接合件，然後可以使用”位置”對話框和”方向”對話框更改它們的位置和方向。 \n 但在只有Denavit-Hartenberg（即D-H）參數的情況下。我們可以通過模型瀏覽器中位於Models / tools / Denavit-Hartenberg聯合creator.ttm中的工具模型來構建接合件。 \n 而當我們沒有關於接合件的位置和方向的信息時。我們需要從導入的網格中提取數據。 第一步是細分原始網格。如果無法進行，可以透過三角形編輯模式進行操作。 \n 成功後即可檢查較小的零組件。 在創建過程中我們要刪除所有不需要的對象，以便可視化/操作。 \n 我們可以通過頁面選擇器工具欄按鈕更改視角，以便從側面查看對象。 適合查看的工具欄按鈕可以派上用場，以正確構圖版本中的對象。 然後，我們切換到頂點編輯模式，並選擇屬於上光盤的所有頂點。 然後我們切換回三角形編輯模式： \n 現在，通過 [Menu bar --> Add --> Joint --> Revolute] 添加旋轉接合件，使其保持選中狀態，然後控制選擇提取的圓柱形狀。在位置對話框的“位置”選項卡上，單擊“應用於選擇”：這基本上將圓柱體的x / y / z座標位置複製到關節。現在兩個位置都相同。在方向對話框中的方向選項卡上，我們還單擊“應用於選擇”：所選對象的方向現在也相同。有時，我們將需要圍繞其自身的參考框架額外旋轉關節90/180度，以獲得正確的方向或旋轉方向。如果需要，我們可以在該對話框的“旋轉”選項卡上執行此操作（在這種情況下，請不要忘記單擊“自有框架”按鈕）。同樣，我們也可以沿關節的軸移動關節，甚至進行更複雜的操作。 \n 現在，我們將接合件複製回到原始場景中，並保存它 （不要忘記定期保存您的工作！） 我們對機器人中的所有關節重複上述過程，並且重新命名它們。 在默認情況下，接合件將分配給可見性層2，但現在，我們將所有關節分配給可見性層10，然後為場景臨時啟用可見性層10，以使這些關節也可視化（默認情況下，僅激活場景的可見性層1-8）。 \n 這就是我們所建立完成的： \n \n', 'tags': '', 'url': '40723153.html'}, {'title': '40723138', 'text': 'Building the dynamic shapes 建立動態形狀 \n 為了模擬真實機器人遇到情況 我們須先設定環境(建立地形) 地形可以為 1.dynamic or static:動態（或非靜態）形狀會掉落並受到外力/扭矩的影響。另一方面，靜態（或非動態）形狀將保持不變，或跟隨其父級在場景層次中的移動。 (類似一般的地形) 2.respondable or non-respondable：可響應形狀會引起與其他可響應形狀的碰撞反應。如果它們是動態的，它們（和/或它們的對撞機）的運動將受到影響 。另一方面，不負責任的形狀如果與其他形狀發生碰撞，則不會計算碰撞響應。 (類似有機關的) \n 上述兩大類又可合併成5大類 pure shapes, pure compound shapes, convex shapes, compound convex shapes, and finally random shapes \n Pure shapes 將穩定並由物理引擎非常有效地處理。 缺點是純形狀的幾何形狀受到限制：主要是長方體，圓柱體和球體。 如果可能的話，將它們用於與其他物品接觸時間較長的物品 （例如，人形機器人的腳，串行操縱器的底座，抓手的手指等） \n Pure compound shapes: 是幾個純形狀的組合。它的性能幾乎與純形狀一樣，並具有相似的特性。 可以通過對幾個純形狀進行分組來生成純複合形狀 \n Convex shapes: 與純形狀相比，它允許使用更通用的幾何形狀（僅要求：它必須是凸形的）。 如果可能，將凸形用於偶爾與其他物品接觸的物品（例如，機器人的各個鏈接）。 \n Compound convex shapes, or convex decomposed shapes: 它的性能幾乎與凸形相同，並具有相似的特性。 \n Random shapes：隨機形狀是既非凸形也不是純淨的形狀。它通常具有較差的性能 \n \n 由此得知建構順序為pure shapes, pure compound shapes, convex shapes, compound convex shapes, and finally random shapes \n 由於我們希望動態形狀僅對物理引擎可見，而對其他計算模塊不可見 因此在object common properties取消選中動態形狀的所有object special properties for the dynamic shapes \n 然後，我們仍然必須將動態形狀配置為dynamic和responseable在shape dynamics properties使用, 檢查主要的本體是否為respondable item,而其他不需要被引響的物件取消Local respondable mask flags 以便不必要的干擾 \n 大多數情況下，我們需要機器人的基礎（即robot_dyn）為非動態（即靜態），否則，如果單獨使用，則機器人可能會在運動過程中掉落。 但是，一旦我們將機器人的底座連接到移動平台上，我們就希望底座變得動態（即非靜態）。 除了機器人的基座之外，所有動態形狀都應下降。附加的視覺形狀將跟隨其動態吊墜。 點擊Compute mass & inertia properties for selected convex shapes基底以外的機構使他符合shape dynamics properties. \n', 'tags': '', 'url': '40723138.html'}, {'title': '40723144', 'text': '現在，我們可以進一步細化/簡化單個形狀。有時， 如果改用凸包，形狀可能會看起來更好。有時，您將 不得不反複使用上述幾種技術，以獲得所需的結果。 以以下網格為例： 上面形狀的問題是，由於其中包含孔，我們無法很好 地簡化它。因此，我們必須通過形狀編輯模式進行更 複雜的處理，在該模式下，我們可以提取同一凸形子 實體的單個元素。此過程可能需要進行多次迭代：我 們首先提取3個近似凸元素。現在，我們忽略作為兩 個孔的一部分的三角形。在形狀編輯模式下編輯形狀 時，可以方便地切換可見性圖層，以查看其他場景項 所覆蓋的內容。 我們最終得到三個形狀的總和，但是其中兩個將需要 進一步改進。現在我們可以擦除作為孔的一部分的三 角形。最後，我們分別提取3種形狀的凸包，然後將 其與[菜單欄-&gt;編輯-&gt;分組/合併-&gt;合併所選形狀]合併 在一起： 在CoppeliaSim中，我們可以啟用/禁用每種形狀的邊 緣顯示。我們還可以指定邊緣顯示時要考慮的角度。 相似的參數是陰影角，它指示形狀將在多方面顯示。 這些參數以及其他一些參數（例如形狀顏色）可以在 形狀屬性中進行調整。到目前為止，在本教程中，我 們僅處理簡單的形狀：簡單的形狀具有一組視覺屬性 （即一種顏色，一個陰影角度等）。如果合併兩個形 狀，則結果將是一個簡單的形狀。您還可以對形狀進 行分組，在這種情況下，每個形狀將保留其視覺屬性 。 在下一步中，我們可以合併邏輯上屬於一起的元素（ 如果它們屬於同一剛性元素，並且具有相同的視覺屬 \n 性）。然後，我們更改各種元素的視覺屬性。調整具 有不同顏色和視覺屬性的幾種形狀的最簡便方法，如 果我們使用特定的字符串來命名顏色，則以後可以輕 鬆地以編程方式更改該顏色，即使該形狀是複合形狀 的一部分。然後，我們選擇所有具有相同視覺屬性的 形狀，然後控制選擇已調整的形狀，然後單擊“應用 於選擇”，一次是“顏色”，一次是其他屬性，在形 狀屬性中：這將轉移所有所選形狀的視覺屬性（如果 提供的話，還包括顏色名稱）。我們最終得到17個 單獨的形狀： 現在，我們可以使用[菜單欄-&gt;編輯-&gt;分組/合併-&gt;分 組所選形狀]對屬於同一鏈接的形狀進行分組。我們 最終得到7個形狀：機器人的基礎（或機器人的層次 結構樹的基礎）和6個移動鏈接。正確命名對像也很 重要：可以通過雙擊場景層次結構中的對象名稱來做 到這一點。基礎是機械手或模型名稱，其他對象包含 基礎對象名稱，例如：robot（基礎 ），robot_link1，robot_proximitySensor等。通過默 認，形狀將分配給可見性層1，但可以在對象通用屬 性中進行更改。默認情況下，僅激活場景的可見性層 1-8。現在，我們有了以下內容（模型 ResizableFloor_5_25模型在模型屬性對話框中暫時 不可見）： 創建或修改形狀時，CoppeliaSim將自動設置其參考 框架的位置和方向。形狀的參考框架將始終位於形狀 的幾何中心。將選擇框架方向，以便形狀的邊界框保 持盡可能小。這並不總是看起來不錯，但是我們隨時 可以隨時調整形狀的參考框架的方向。現在，我們可 以使用[菜單欄-&gt;編輯-&gt;重定向邊界框-&gt;使用世界參考 \n 框架]重新調整所有已創建形狀的參考框架。您有更 多選項可以在形狀幾何對話框中重新定向參考框架。 \n', 'tags': '', 'url': '40723144.html'}, {'title': '40523241', 'text': "建立一個可見形體 \n 每當建立一個新的模型，首先處理可見的外形:動態方面(底層有更多簡單優化的模型)，接頭，感測器…等等。將會在後面的段落一一介紹。 \n \n 現在很快地可以從CoppeliaSim的路徑中[工具列🡪新增🡪基本形狀🡪…]建造一個基本形狀。做了這個步驟之後，可以建立單純的形狀或規則的形狀，單純的形體能在動態互動中更完善，也能夠確切不斷的變化(掉落，碰撞，但是在後面的段落中這是有缺陷的)，基本形狀會有簡單的網格，或許在這軟體中沒有包含足夠的細節或準確的幾何形狀。可以從其他的軟體輸入網格。 \n 當從其他軟體輸入CAD檔，重點是在CAD檔的準確性是不嚴格的，即不包含太多三角網格。這項要求很重要，因為巨大模型的顯示速度會很慢，並且還會減慢以後可能使用的各種計算模塊（例如最小距離計算或動力學）。以下示例通常是不成功的（即使我們會在後面看到，即使有方法可以簡化CoppeliaSim中的數據）: \n \n 上面的CAD數據非常重要：它包含許多三角網格（超過47'000個），如果我們只在新的場景中使用單個三角網格的實例，這是可以的。但是大多數時候，您將需要模擬同一機器人的多個實例，連接各種類型的抓手，並可能使這些機器人與其他機器人，設備或環境進行交互。在這種情況下，模擬場景可能很快變得太慢。通常，我們建議對不超過2萬個三角形的機器人進行建模，但是在大多數情況下，5 000至10 000個三角網格也可以。記住：在幾乎所有方面，少即是好。 \n \n 是什麼使上述模型如此重要？首先，包含孔和小細節的模型將需要更多的三角形面才能正確表示。因此，如果可能，請嘗試從原始模型數據中刪除所有的孔，螺釘，物體的內部等。如果您將原始模型數據表示為參數化曲面/對象，則通常在大多數情況下只需選擇並刪除它們即可（例如在Solidworks中）。第二個重要步驟是以有限的精度導出原始數據：大多數CAD應用程序都允許您指定導出的網格的細節級別。當工程圖由大小對象組成時，分幾步導出對象可能也很重要。這是為了避免大對象定義太精確（三角形太多）和小對象定義太粗（三角形太少）：首先簡單地導出大對象（通過調整所需的精度設置），然後導出小對象（通過調整精度設置） ）。 \n \n CoppeliaSim當前支持以下CAD數據格式：OBJ，STL，DXF，3DS（僅Windows）和Collada。還支持URDF，但此處未提及，因為它不是基於純網格的文件格式。 \n \n 現在，假設我們已按照上一節中所述應用了所有可能的簡化。導入後，我們可能最終仍然會留下一個沉重的網格： \n \n 您會注意到整個機器人是作為單個網格導入的。稍後我們將看到如何對其進行適當劃分。還要注意導入的網格的方向錯誤：最好保持其方向不變，直到構建整個模型為止，因為如果在以後的階段中我們要導入與同一機器人相關的其他項目，它們將自動具有相對於原始網格的正確位置/方向。 \n \n 在此階段，我們可以使用多種功能來簡化網格： \n \n 自動網格劃分：允許為未通過公共邊鏈接在一起的所有元素生成新形狀。這並不總是適用於選定的網格，但是總是值得一試的，因為與必須同時處理所有元素相比，處理網格元素可以為我們提供更多的控制權。可以通過[菜單欄->編輯->分組/合併->分割所選形狀]訪問該功能。有時，網格劃分會超出預期。在這種情況下，只需將邏輯上屬於一起的元素（即，具有相同的視覺屬性並且屬於同一鏈接的一部分）合併回一個單一形狀（[菜單欄->編輯->分組/合併->合併選定的形狀]）。 \n 提取凸面形體：通過將其轉換為凸面形體來簡化網格。可以通過[菜單欄->編輯->將選擇變形為凸形]來訪問該功能。 \n 抽取網格：減少網格中包含的三角形數量。可以通過[菜單欄->編輯->縮小所選形狀...]訪問該功能。 \n 刪除網格的內部：允許通過刪除其內部來簡化網格。此功能基於視覺傳感器，根據所選設置可能會或多或少地令人滿意。可以通過[菜單欄->編輯->提取選定形狀的內部]訪問該功能。 \n 沒有/可以應用上述功能的預定義順序（列表中的第一項除外，應始終首先嘗試該項），它在很大程度上取決於我們要簡化的網格的幾何形狀。下圖說明了應用於導入的網格的上述功能（假設列表中的第一項對我們不起作用）： \n \n 請注意，凸面形體在現階段如何對我們沒有幫助。我們決定首先使用網格抽取功能，然後運行兩次該功能，以將三角網格的數量總共除以50。完成後，我們提取簡化形狀的內部並將其丟棄。我們最終得到的網格總共包含2'660個三角形（原始導入的網格包含了136'000個三角網格！）。形狀包含的三角網格/頂點的數量可以在形狀幾何對話框中看到。對於整個機器人模型，2'660三角網格是極少的三角形，因此視覺外觀可能會因此受到影響。 \n \n 在這一階段，我們可以開始將機器人劃分為單獨的鏈接（請記住，我們目前整個機器人只有一個形狀）。您可以通過兩種不同的方式執行此操作： \n \n 自動網格劃分：此功能已在上一節中進行了描述，它將檢查形狀並為未通過公共邊鏈接在一起的所有元素生成新形狀。這並不總是有效，但總是值得嘗試的。可以通過[菜單欄->編輯->分組/合併->分割所選形狀]訪問該功能。 \n 手動網格劃分：通過三角網格編輯模式，您可以手動選擇邏輯上不屬於邏輯的三角網格，然後單擊“提取形狀”。這將在場景中生成新形狀。完成該操作後，刪除選定的三角網格。 \n 對於我們的網格，方法1可以正常工作： \n \n Build the visible shape \n When building a new model, first, we handle only the visual aspect of it: the dynamic aspect (its undelying even more simplified/optimized model), joints, sensors, etc. will be handled at a later stage. \n We could now directly create primitive shapes in CoppeliaSim with [Menu bar --> Add --> Primitive shape --> ...]. When doing this, we have the option to create\xa0 pure shapes, or regular shapes . Pure shape will be optimized for dynamic interaction, and also directly be dynamically enabled (i.e. fall, collide, but this can be disabled at a later stage). Primitive shapes will be simple meshes, which might not contain enough details or geometric accuracy for our application. Our other option in that case would be to import a mesh from an external application. \n When importing CAD data from an external application, the most important is to make sure that the CAD model is not too heavy, i.e. doesn't contain too many triangles. This requirement is important since a heavy model will be slow in display, and also slow down various calculation modules that might be used at a later stage (e.g.\xa0 minimum distance calculation , or\xa0 dynamics ). Following example is typically a no-go (even if, as we will see later, there are means to simplify the data within CoppeliaSim): \n \n Above CAD data is very heavy: it contains many triangles (more than 47'000), which would be ok if we would just use a single instance of it in an empty scene. But most of the time you will want to simulate several instances of a same robot, attach various types of grippers, and maybe have those robots interact with other robots, devices, or the environment. In that case, a simulation scene can quickly become too slow. Generally, we recommend to model a robot with no more than a total of 20'000 triangles, but most of the time 5'000-10'000 triangles would just do fine as well. Remember: less is better, in almost every aspect. \n What makes above model so heavy? First, models that contain holes and small details will require much more triangular faces for a correct representation. So, if possible, try to remove all the holes, screws, the inside of objects, etc. from your original model data. If you have the original model data represented as parametric surfaces/objects, then it is most of the time a simple matter of selecting the items and deleting them (e.g. in Solidworks). The second important step is to export the original data with a limited precision: most CAD applications let you specify the level of details of exported meshes. It might also be important to export the objects in several steps, when the drawing consists of large and small objects; this is to avoid having large objects too precisely defined (too many triangles) and small objects too roughly defined (too few triangles): simply export large objects first (by adjusting the desired precision settings), then small objects (by adjusting up precision settings). \n CoppeliaSim supports currently following CAD data formats:\xa0 OBJ ,\xa0 STL ,\xa0 DXF ,\xa0 3DS \xa0(Windows only), and\xa0 Collada .\xa0 URDF \xa0is also supported, but not mentionned here since it is not a pure mesh-based file format. \n Now suppose that we have applied all possible simplifications as described in previous section. We might still end-up with a too heavy mesh after import: \n \n You can notice that the whole robot was imported as a single mesh. We will see later how to divide it appropriately. Notice also the wrong orientation of the imported mesh: best is to keep the orientation as it is, until the whole model was built, since, if at a later stage we want to import other items that are related to that same robot, they will automatically have the correct position/orientation relative to the original mesh. \n At this stage, we have several functions at our disposal, to simplify the mesh: \n \uf0b7\xa0  Automatic mesh division: \xa0allows to generate a new shape for all elements that are not linked together via a common edge. This does not always work for the selected mesh, but is always worth a try, since working on mesh elements gives us more control than if we had to work on all elements at the same time. The function can be accessed with [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes]. Sometimes, a mesh will be divided more than expected. In that case, simply merge elements that logically belong together (i.e. that will have the same visual attributes and that are part of the same link) back into one single shape ([Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes]). \n \uf0b7\xa0  Extract the convex hull: \xa0allows to simplify the mesh by transforming it into a convex hull. The function can be accessed with [Menu bar --> Edit --> Morph selection into convex shapes]. \n \uf0b7\xa0  Decimate the mesh: \xa0allows to reduce the number of triangles contained in the mesh. The function can be accessed with [Menu bar --> Edit --> Decimate selected shape...]. \n \uf0b7\xa0  Remove the inside of the mesh: \xa0allows to simplify the mesh by removing its inside. This function is based on\xa0 vision sensors \xa0and might give more or less satisfying results depending on the selected settings. The function can be accessed with [Menu bar --> Edit --> Extract inside of selected shape]. \n There is no predefined order in which above functions can/should be applied (except for the first item in the list, which should always be tried first), it heavily depends on the geometry of the mesh we are trying to simplify. Following image illustrates above functions applied to the imported mesh (let's suppose the first item in the list didn't work for us): \n Notice how the convex hull doesn't help us at this stage. We decide to use the mesh decimation function first, and run the function twice in order to divide the number of triangles by a total of 50. Once that is done, we extract the inside of the simplified shape and discard it. We end-up with a mesh containing a total of 2'660 triangles (the original imported mesh contained more than 136'000 triangles!). The number of triangles/vertices a shape contains can be seen in the\xa0 shape geometry dialog . 2'660 triangles are extremely few triangles for a whole robot model, and the visual appearance might suffer a little bit from it. \n At this stage we can start to divide the robot into separate links (remember, we currently have only a single shape for the whole robot). You can do this in two different ways: \n \uf0b7\xa0  Automatic mesh division: \xa0this function, which was already described in previous section, will inspect the shape and generate a new shape for all elements that are not linked together via a common edge. This does not always work, but is always worth a try. The function can be accessed with [Menu bar --> Edit --> Grouping/merging --> Divide selected shapes]. \n \uf0b7\xa0  Manual mesh division: \xa0via the the\xa0 triangle edit mode , you can manually select the triangles than logically belong together, then click\xa0 Extract shape . This will generate a new shape in the scene. Delete the selected triangles after that operation. \n In the case of our mesh, method 1 worked fine: \n \n", 'tags': '', 'url': '40523241.html'}]};