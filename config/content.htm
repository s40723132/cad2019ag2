<h1>About</h1>
<p>此內容管理系統以 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作.</p>
<h4>利用 cmsimde 建立靜態網誌方法:</h4>
<p>1. 在 github 建立倉儲, git clone 到近端</p>
<p>2. 參考 <a href="https://github.com/mdecourse/newcms">https://github.com/mdecourse/newcms</a>, 加入除了 cmsimde 目錄外的所有內容</p>
<p>以 git submodule add <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> cmsimde</p>
<p>建立 cmsimde 目錄, 並從 github 取下子模組內容.</p>
<p>3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.</p>
<p>動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.</p>
<p>4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行:</p>
<p>git clone --recurse-submodules <a href="https://github.com/mdecourse/newcms.git">https://github.com/mdecourse/newcms.git</a></p>
<h1>Develop</h1>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443 就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容.</p>
<p>cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版.</p>
<p>init.py 位於  up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.</p>
<h1>Solvespace</h1>
<h2>Tutorial practice</h2>
<p>tutorial 1 simple plate</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/2qB2N_a5knE" width="560"></iframe></p>
<p>tutorial 2 three-way connector</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/eMqphj2_Dfo" width="560"></iframe></p>
<p><span>tutorial_3_ Sketch Rotation around an Axis</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/ivU0mhcnOic" width="560"></iframe></span></p>
<p><span>tutorial_4_Assembly</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/5MakqM7mXik" width="560"></iframe></span></p>
<p><span>tutorial_6_Christmas Tree(BONUS)</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/ij8HWECJKr4" width="560"></iframe></span></p>
<p><span>tutorial_7_Constrained Movement</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/5MFpgFHV4KA" width="560"></iframe></span></p>
<p><span>tutorial_8_Interactive 3D Model in Browser</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="341" src="//www.youtube.com/embed/MQsw2OHek1Y" width="560"></iframe></span><yt-formatted-string class="style-scope ytd-video-primary-info-renderer" force-default-style="">   tutorial 11: Cubic Bezier Spline tool (Vase)</yt-formatted-string></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/tXuJyXvl5R0" width="560"></iframe></p>
<p><span></span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="341" src="//www.youtube.com/embed/MQsw2OHek1Y" width="560"></iframe></span></p>
<p><span>tutorial_9_a Simple Gear</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="341" src="//www.youtube.com/embed/27gea-a8HsY" width="560"></iframe></span></p>
<p>tutorial_10_<span>Fidget Spinner</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/ypjNnid1hiI" width="560"></iframe></span></p>
<p><span>tutorial_11_cubic bezier spline tool (vase)</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/tXuJyXvl5R0" width="560"></iframe></span></p>
<p>tutorial_12_How to create a Mechanical Linked System</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/f7UoP-ljM70" width="560"></iframe></p>
<p><yt-formatted-string class="style-scope ytd-video-primary-info-renderer" force-default-style="">繪圖驗證1</yt-formatted-string></p>
<p><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/MSzyxRDbWFA" width="541"></iframe></p>
<p><span>繪圖驗證3</span></p>
<p><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/ODac8buo9Kc" width="541"></iframe></p>
<p>繪圖驗證4</p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/zWY6ab5KQrM" width="541"></iframe></span></p>
<p><span>繪圖認證6</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/TLXOxAQXPgg" width="541"></iframe></span></p>
<p><span>繪圖認證7</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/s9idNH0HUJs" width="541"></iframe></span></p>
<p><span>繪圖認證8</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/_T9D541EHpg" width="541"></iframe></span></p>
<p><span>繪圖認證9</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/a6wgqbfW7VY" width="541"></iframe></span></p>
<p><span>繪圖認證10</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/9iY2umaAYEg" width="541"></iframe></span></p>
<p><span>繪圖認證11</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/TBeTW-aU2uk" width="541"></iframe></span></p>
<p><span>繪圖認證12</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/exCYhKFAi74" width="541"></iframe></span></p>
<p><span>繪圖認證13</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/_5Js7B2QU60" width="541"></iframe></span></p>
<p><span>繪圖認證14</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/qLmuCOwY2Os" width="541"></iframe></span></p>
<p><span>繪圖認證15</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/ALmPCuwFNzs" width="541"></iframe></span></p>
<p><span>繪圖認證16</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/_VOkCMqc9E0" width="541"></iframe></span></p>
<p><span>繪圖認證17</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/_WHaezwLfZA" width="541"></iframe></span><span></span></p>
<p><span>繪圖驗證18</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/LQafZjuErl4" width="541"></iframe></span></p>
<p><br/><span></span></p>
<h2>Car model</h2>
<p><img alt="" height="319" src="/images/carbady.jpg" width="441"/></p>
<p>檔案位子:carmodel/carbody.slvs</p>
<p>參考圖像:<a href="https://www.google.com/search?q=rainbow+six++Unmanned+vehicle&amp;rlz=1C1GCEA_enTW812TW812&amp;sxsrf=ACYBGNRHnkoLe0kouEp3qp6hRlMV8B3EQQ:1571582838834&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=0ahUKEwjo1d-miqvlAhUryIsBHRXQCT0Q_AUIEigB&amp;biw=871&amp;bih=843#imgrc=_">https://www.google.com/search?q=rainbow+six++Unmanned+vehicle&amp;rlz=1C1GCEA_enTW812TW812&amp;sxsrf=ACYBGNRHnkoLe0kouEp3qp6hRlMV8B3EQQ:1571582838834&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=0ahUKEwjo1d-miqvlAhUryIsBHRXQCT0Q_AUIEigB&amp;biw=871&amp;bih=843#imgrc=_</a></p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt; bce730699bbf79fca6977ab6b67993bb4e3ee75c</p>
<h1>Solidworks</h1>
<h2>開發起源</h2>
<p>起初Jon Hirschtick 和 Axel Bichara在創業班中組成一個團隊，他們寫了一個商業企劃，內容是叫做 Premise的 新CAD軟體公司。</p>
<p>Premise最初的軟體產品是Design View，是一個二維的繪圖軟體。雖然軟體的開發很成功但是由於市場太小以至於無法蓬勃發展起來，後來就被Computervision公司給收購了。</p>
<p><span>Jon Hirschtick 和 Axel Bichara也到了Computervision的管理團隊待了一陣子，不過後來Axel Bichara待了大約一年就離開回到法國攻讀MBA學位。</span></p>
<p><span>1993年8月Jon Hirschtick也離開了Computervision，因為他不知道他下一步該做什麼也覺得他除了經營公司以外應該還有其他的事情可以做。</span></p>
<p><span>1994年1月一個創造低成本桌面設計系統基於實體模型技術的想法開始出現，於是Jon Hirschtick組成了一個團隊，成員包括 Bob Zuffante, Scott Harris, Constantine Dokos和Tommy Li，最終發展出 的產品就為Solidworks。</span></p>
<h2>Solidworks 繪圖練習</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/RrWQkUmprDc" width="560"></iframe></p>
<h1>Inventor</h1>
<h2>Practice</h2>
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt; e57712a9a4b0cd2222e8ab8be05fcaf682d69cd9</p>
<p><iframe allowfullscreen="allowfullscreen" height="360" src="//www.youtube.com/embed/OZTDHbkFpT4" width="541"></iframe></p>
<h1>NX12</h1>
<h2>NX12繪圖練習</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Xuw2iyEzRIE" width="560"></iframe></p>
<h2>教材整理</h2>
<h3>Ch1~2</h3>
<p><strong>第1章主要介紹CAD/CAM/CAE的定義及本課本其他章的簡介</strong><br/><strong>第2.1章如何打開nx12的文件</strong><br/><strong>第一步打開nx12</strong><br/><strong>第二步如何打開新的文件　使用頂部按鈕打開新的文件 或 選用菜單打開 或 使用"ctrl+n" 然後跳出介面 確認尺寸為毫米 可以改名稱及位置</strong><br/><strong>第三步如何打開新的零件文件　使用頂部按鈕打開新的零件文件 或 選用菜單打開 或 使用"ctrl+ｏ"</strong><br/><strong>第2.2章如何打印，保存和關閉零件文件</strong><br/><strong>打印 File →Print 選擇要使用的打印機或指定編號 打印份數，紙張尺寸等。可以為所有三個選擇比例尺寸。可以選擇通過單擊來打印，即線框實體模型輸出下拉菜單</strong><br/><strong>保存 File →Save </strong><br/><strong>關閉零件文件 File →Close</strong><br/><strong>第2.3章如何使用滑鼠及nx12的介面介紹</strong><br/><strong>第2.4章圖層</strong><br/><strong>第2.5章座標系統</strong><br/><strong>第2.6章工具欄</strong></p>
<p><strong>實際操作影片</strong></p>
<p><strong></strong></p>
<p><strong><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/nLp4F3K6zV0" width="560"></iframe></strong></p>
<h3>Ch3~4</h3>
<p>Chapter 3<br/>3-1 overview(總結)<br/>(1)A sketch can be extruded(一個草圖可以被拉伸)<br/>(2)A sketch can be revolved(草圖可以旋轉)<br/>(3)A sketch can be swept along a guide (line)-草圖可以沿參考線（線）進行掃掠<br/>Features created from a sketch are associated with it; i.e., if<br/>the sketch changes so do the features.<br/>(從草圖創建的特徵與之關聯:草圖也會更改，特徵也會更改。)</p>
<p>3-2 SKETCHING ENVIRONMENT(草圖環境)<br/>(1)Choose Menu →Insert →Sketch(選擇目錄→插入→平面)<br/>(2)Choose Sketch in Home toolbar(在工具欄中選擇草圖)</p>
<p>3-3 SKETCH CURVE TOOLBAR (草圖曲線工具欄)<br/>3-4 CONSTRAINTS TOOLBAR(約束工具)<br/>Chapter 4<br/>4-1 TYPES OF FEATURES(功能類型)<br/>4.1.1 Primitives (原語)<br/>‧ Block(塊)<br/>‧ Cylinder(圓筒)<br/>‧ Cone(圓錐)<br/>‧ Sphere(球)<br/>4.1.2 Reference Features(參考功能)<br/>Click menu → Insert → Datum / Point or preset datum plane in the feature group<br/>Ribbon bar to see different Reference Feature options: datum plane, datum<br/>Axis, datum CSYS and points<br/>(點擊目錄→插入→基準/點或在的特徵組中點擊基準平面<br/>功能區條以查看不同的“參考特徵”選項：基準平面，基準<br/>軸，基準CSYS和點)<br/>4.1.3 Swept Features (功能)<br/>‧ Extruded Body(擠出)<br/>‧ Revolved Body(旋轉)<br/>‧ Sweep along Guide(掃出)<br/>‧ Tube(管狀)<br/>‧ Styled Sweep(樣式掃描)<br/>4.1.4 Remove Features (刪除特徵)<br/>‧ Hole (鑽孔)<br/>‧ Pocket(口袋)<br/>‧ Slot (挖槽)<br/>‧ Groove (槽)</p>
<p></p>
<h3>Ch5~6</h3>
<p><strong></strong></p>
<p><strong>5-1</strong><strong>如何選擇平面與如何視圖</strong><strong><br/>5-2<br/>設定紙張尺寸大小、第幾角法</strong><strong><img alt="" height="370" src="/images/2.jpg" width="480"/></strong></p>
<p><strong>切換視角與關閉不必要的線條</strong></p>
<p><strong><img alt="" height="436" src="/images/3.jpg" width="428"/><br/>5-3<br/>尺寸標註</strong></p>
<p><strong><img alt="" height="121" src="/images/4.jpg" width="409"/><br/>5-4<br/>切換剖視圖</strong></p>
<p><strong><img alt="" height="578" src="/images/5.jpg" width="536"/><br/>5-5<br/>在實體面標註尺寸</strong></p>
<p><strong><img alt="" height="114" src="/images/6.jpg" width="276"/></strong></p>
<p><b>5-6</b></p>
<p><b>草圖繪製,給予形狀公差</b></p>
<p><b><img alt="" height="509" src="/images/7.jpg" width="481"/></b></p>
<p><b>6-1</b></p>
<p><b>分辨零件、組合件</b></p>
<p><b>6-2</b></p>
<p>使用Top-Down Approach(由上而下的畫法),Bottom-Up Approach(由下而上的畫法)</p>
<p>6-3</p>
<p>了解零件如何互相約束</p>
<p>6-4</p>
<p>使用不同的約束</p>
<p>分別為:<strong>對齊;同心;距離;平行;垂直;鍵合;置中;角度</strong></p>
<p><img alt="" height="576" src="/images/8.jpg" width="571"/></p>
<p>6-5,6-6</p>
<p>操作實際例題</p>
<h3>Ch7</h3>
<p>Ch7  自由曲面的建模</p>
<p>此章節主要在講述可以利用何種方法來建構曲面</p>
<p>1.利用"點"來建立曲面</p>
<p>(1)利用四個點來建立一曲面</p>
<p>(2)以矩形點陣列構成的多個點來建立一曲面</p>
<p>(3)定義的點形成矩形陣列與穿過它們的線相切</p>
<p>----------------------------------------------------------------------------------</p>
<p>2.利用"線"來建立曲面</p>
<p>(1)用兩條大致平行的線</p>
<p>(2)3條或以上大致平行的線</p>
<p>(3)由至少4條剖面線，且存在至少2條線段方向關係為垂直且平行於面區域</p>
<p>(4)由至少2條剖面線且有2條大致垂直的線和2條剖面線有重和關係</p>
<p><span>----------------------------------------------------------------------------------</span></p>
<p>3.利用面來建立自由曲面</p>
<p>(1)利用原有的曲面來偏移</p>
<p>(2)利用原有曲面的面或邊來做延伸的功能</p>
<h3>Ch8</h3>
<h4><strong>第8章－有限元分析</strong></h4>
<p>Finite Element Analysis (FEA)有限元分析<span>-</span>預測結構或流體對應用因素（例如力，壓力，熱量和振動等等<span>...)</span>而本章我們我們重點在於處理實體零件的結構應力和應變分析也就是應力和位移<span>.</span></p>
<h4><strong>8.1.1.  element(元素/元件)的形狀和節點</strong></h4>
<p>元素可分為尺寸<span>(dimensions)</span>數和節點<span>(nodes)</span>數兩大因素，而這兩大因素則用於分離化(discretization)</p>
<p><img alt="" height="870" src="/images/2019-12-13_11-15-35_LI (2).jpg" width="604"/></p>
<h3>Ch9</h3>
<p>第<span>9</span>章</p>
<p>此章節在介紹如何使用<span>NX12</span>生成用於三軸立式加工中心的<span>CNC</span>代碼製造模組，該模組使我們可以對鑽孔，銑削，車削和線切割<span>EDM</span>刀具路徑進行編程和一些後續處理。</p>
<p>9-1 入門</p>
<p>創建新檔案<span>→</span>設定加工環境<span>→</span>操作導航器<span>(</span>註<span>1)→</span>設定機器座標系統<span>(MCS) →</span>定義幾何</p>
<p>9-2 創建操作</p>
<p>建立新操作<span>→</span>建立新工具並選擇<span>→</span>設定工具路徑<span>→</span>跨距和<span>Scallop</span>高度<span>(</span>註<span>2)→</span>設定每次切削深度<span>→</span>設定切削深度<span>→</span>設定迴避點<span>→</span>調整速度與進給</p>
<p>9-3 生成程序和驗證</p>
<p>生成程序<span>→</span>顯示刀具路徑<span>→</span>模擬刀具路徑<span>→</span>鑿檢驗<span>(</span>註<span>3)</span></p>
<p>9-4 操作方法</p>
<p>粗加工→半精加工<span>→</span>整理零件內外輪廓→精加工外部輪廓<span>→</span>精加工內部輪廓</p>
<p>9-5 後期處理</p>
<p>創建<span>CLSF→</span>後期處理</p>
<p> </p>
<p>註<span>1 </span>“操作導航器”提供有關所創建程序的信息以及有關刀具，方法和策略的相應信息，可以在不同的類別列表中查看程序列表。</p>
<p> </p>
<p>註<span>2 </span>跨距的大小和刀具直徑將決定每步之間的<span>Scallop</span>高度。 減小跨步距離將使<span>Scallop</span>高度減低，但需要更多的步幅，因此需要更多的時間來加工特徵。</p>
<p> </p>
<p>註<span>3 </span>鑿檢驗用於驗證刀具是否確實從工件上去除了多餘的材料。在製造過程有缺陷的零件有兩種可能。一種是去除多餘的材料，另一種是留下應該清除的材料。在大多數情況下，前者更不理想，因為其不可能重新設計。</p>
<h1>Webots</h1>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream =======</p>
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 964fdc740c8f66990d245210f0d18d30016f4138</p>
<p>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes</p>
<h2>tutorial</h2>
<p>tutorial_1_my_first_simulation</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/qqo86Bsxllg" width="560"></iframe></p>
<h1>W17 協同任務</h1>
<p><strong>Building a clean model tutorial</strong></p>
<p><span>40723144、40523241:Building the visible shapes</span></p>
<p><span>40723153:Building the joints</span></p>
<p><span>40723138:Building the dynamic shapes</span></p>
<p><span>40723118、40723132:Model definition</span></p>
<p><span>40723145:Webots modification of the environment</span></p>
<p><span>各組員在完成翻譯後自行建立一個h2的標題(以自己學號命名)將自己所做的部分打在裡面</span></p>
<h2>40723145</h2>
<p><strong>Webots Tutorial</strong></p>
<p><strong>Modification of the Environment</strong></p>
<p>在這個教材中包含了<br/>1.建立一顆球來跟所建立的環境互動<br/>2.物件中的各個節點的意義和應用<br/>3.設定物理性質<br/>4.利用DEF的功能來避免做重複性的屬性設定<strong><br/></strong></p>
<p>操作步驟:<br/><span style="color: #000000; background-color: #ffff00;">A New Simulation:</span><br/>Hands-on #1<br/>將Webots Tutorial 1 所建立的my_first_simulation.wbt檔案另存一個新的wbt檔</p>
<p><span style="background-color: #ffff00;">Modifying the Floor:</span><br/>預設的 RectangleArena 是一個靜態的環境(沒有物理性質的節點)而且被牆壁所圍繞，在Wobots物件庫中有多種floor的類型可供選擇<br/>Hands-on #2<br/>先將原本的 RectangleArena 刪除。選取TexturedBackroundLight後再按右鍵選Add，在左方的清單中選取PROTO nodes (Webots Projects) / objects / floors / Floor (Solid)就會加入一個新的floor形式</p>
<p>Hands-on #3<br/>在左邊的選單中有一個Floor，拉開他的選單後將size改為1m*1m</p>
<p><span style="background-color: #ffff00;">The Solid Node:</span><br/>Solid就是表剛體的意思。在Solid節點中會有各種不同自己要設定的特性，但其中最重要的一點就是在Physics設定中要將物理特性利用Add加入</p>
<p><span style="background-color: #ffff00;">Create a Ball:</span><br/>在這段中要加入一顆球體，球體的節點中可以更改各種參數<br/>Hands-on #4<br/>1.先選取Solid節點再利用Add功能來加入Shape的節點，在Shape節點中加入球體<br/>2.將metalness數值改為0，roughness數值改為1<br/>3.加入另一個球體節點在boundingObject清單中<br/>4.加入Physics節點在Physics清單中</p>
<p><span style="background-color: #ffff00;">Geometries:</span><br/>Hands-on #5<br/>將球體的半徑改為0.05，subdivision改為2</p>
<p><br/><span style="background-color: #ffff00;">DEF-USE Mechanism:</span><br/>DEF功能可以先將一個物體或是外觀選項做定義的動作，之後在做相同的物體時可以利用DEF功能套用原本的設定<br/>Hands-on #6<br/>1.點選新建的球體後會有一欄DEF的空格，輸入BALL_GEOMETRY<br/>2.選擇boundingObject的區域後將原本的刪除掉<br/>3.選擇boundingObject的區域後利用Add加入USE / BALL_GEOMETRY</p>
<p>Hands-on #7<br/>建立一個新的球體，利用DEF的功能來設定相同屬性的球體</p>
<p><span style="background-color: #ffff00;">Add Walls:</span><br/>Hands-on #8<br/>加入四面沒有物理特性的牆並使用只有一個定義的Shape節點</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/BaUl_kdEpQU" width="560"></iframe></p>
<h2>40723138</h2>
<p><span></span></p>
<p>Building the dynamic shapes 建立動態形狀</p>
<p><br/>為了模擬真實機器人遇到情況<br/>我們須先設定環境(建立地形)<br/>地形可以為<br/>1.dynamic or static:動態（或非靜態）形狀會掉落並受到外力/扭矩的影響。另一方面，靜態（或非動態）形狀將保持不變，或跟隨其父級在場景層次中的移動。<br/>(類似一般的地形)<br/>2.respondable or non-respondable：可響應形狀會引起與其他可響應形狀的碰撞反應。如果它們是動態的，它們（和/或它們的對撞機）的運動將受到影響<br/>。另一方面，不負責任的形狀如果與其他形狀發生碰撞，則不會計算碰撞響應。<br/>(類似有機關的)</p>
<p>上述兩大類又可合併成5大類<br/>pure shapes, pure compound shapes, convex shapes, compound convex shapes, and finally random shapes</p>
<p><br/>Pure shapes<br/>將穩定並由物理引擎非常有效地處理。<br/>缺點是純形狀的幾何形狀受到限制：主要是長方體，圓柱體和球體。<br/>如果可能的話，將它們用於與其他物品接觸時間較長的物品<br/>（例如，人形機器人的腳，串行操縱器的底座，抓手的手指等）</p>
<p><br/>Pure compound shapes:<br/>是幾個純形狀的組合。它的性能幾乎與純形狀一樣，並具有相似的特性。<br/>可以通過對幾個純形狀進行分組來生成純複合形狀</p>
<p><br/>Convex shapes:<br/>與純形狀相比，它允許使用更通用的幾何形狀（僅要求：它必須是凸形的）。<br/>如果可能，將凸形用於偶爾與其他物品接觸的物品（例如，機器人的各個鏈接）。</p>
<p><br/>Compound convex shapes, or convex decomposed shapes:<br/>它的性能幾乎與凸形相同，並具有相似的特性。</p>
<p>Random shapes：隨機形狀是既非凸形也不是純淨的形狀。它通常具有較差的性能</p>
<p></p>
<p>由此得知建構順序為pure shapes, pure compound shapes, convex shapes, compound convex shapes, and finally random shapes</p>
<p>由於我們希望動態形狀僅對物理引擎可見，而對其他計算模塊不可見<br/>因此在object common properties取消選中動態形狀的所有object special properties for the dynamic shapes</p>
<p>然後，我們仍然必須將動態形狀配置為dynamic和responseable在shape dynamics properties使用,<br/>檢查主要的本體是否為respondable item,而其他不需要被引響的物件取消Local respondable mask flags<br/>以便不必要的干擾</p>
<p>大多數情況下，我們需要機器人的基礎（即robot_dyn）為非動態（即靜態），否則，如果單獨使用，則機器人可能會在運動過程中掉落。<br/>但是，一旦我們將機器人的底座連接到移動平台上，我們就希望底座變得動態（即非靜態）。<br/>除了機器人的基座之外，所有動態形狀都應下降。附加的視覺形狀將跟隨其動態吊墜。<br/>點擊Compute mass &amp; inertia properties for selected convex shapes基底以外的機構使他符合shape dynamics properties.</p>
<h2>40723132</h2>
<p><span>Now we are ready to define our model. We start by building the model herarchy: we attach the last dynamic robot link (</span><em>robot_link_dyn6</em><span>) to its corresponding joint</span></p>
<p>現在我們準備定義模型了。我們從建立模型層次結構開始：通過選擇robot_link_dyn6，然後控制選擇robot_joint6，然後選擇[目錄-&gt;編輯-&gt;創建最後一個選定的對象，將最後一個動態機我們還可以通過簡單地將對象robot_link_dyn6拖曳到場景層次結構中的器人鏈接（robot_link_dyn6）附加到其相應的關節。</p>
<p>then control-selecting<span> </span><em>robot_joint6</em>, then [Menu bar --&gt; Edit --&gt; Make last selected object parent]. We could also have done this step by simply dragging object<span> </span><em>robot_link_dyn6</em><span> </span>onto<span> </span><em>robot_link6</em><span> </span>in the<span> </span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy">scene hierarchy</a>. We go on by now attaching<span> </span><em>robot_joint6</em><span> </span>to<span> </span><em>robot_link_dyn5</em>, and so on, until arrived at the base of the robot. We now have following scene hierarchy:<span>It is nice and more logical to have a simple name for the model base, since the model base will also represent the model itself. So we rename </span><em>robot</em><span><span> </span>to<span> </span></span><em>robot_visibleBase</em><span>, and<span> </span></span><em>robot_dyn</em><span><span> </span>to<span> </span></span><em>robot</em><span>. Now we select the base of the hierarchy tree (i.e. object<span> </span></span><em>robot</em><span>) and in the<span> </span></span><a href="http://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">object common properties</a><span><span> </span>we enable<span> </span></span><strong>Object is model base</strong><span>.<span> We also enable <strong>Object/model can transfer or accept DNA</strong><span>. A model bounding box appeared, encompassing the whole robot. The bounding box however appears to be too large: this is because the bounding box also encompasses the invisible items, such as the joints. We now exclude the joints from the model bounding box by enabling the<span> </span></span><strong>Don't show as inside model selection</strong><span><span> </span>item for all joints. We could do the same procedure for all invisible items in our model. This is also a useful option in order to also exclude large sensors or other items from the model bounding box. We now have following situation:</span></span></span></p>
<p><br/>現在，我們將robot_joint6附加到robot_link_dyn5上，依此類推，直到到達機器人的底部。現在我們有以下場景層次，先為模型建立一個簡單的名稱且合乎邏輯的，因為模型庫也代表模型本身，因此將robot重命名為robot_visibleBase，並將robot_dyn重命名為robot。現在我們選擇結構樹，並在公共屬性啟用模型基礎，我們可以使模型可以移動。但是邊框含不可見的選項，例如關節。現在，利用對所有關節啟用"不顯示"為內部模型選擇項，將關節從模型邊界框中排除我們可以對模型中的所有不可見項執行相同的過程。這也是一個有用的選項，可以將大型傳感器或其他項目也排除在模型邊界框之外。我們現在有以下情況：</p>
<p><span>We now protect our model from accidental modification. We select all visible objects in the robot, then enable </span><strong>Select base of model instead</strong><span>: if we now click a visible link in the scene, the base of the robot will be selected instead. This allows us to manipulate the model as if it was a single object. We can still select visible objects in the robot via control-shift-clicking in the scene, or by selecting the object in the scene hierarchy. We now put the robot into a correct default position/orientation. First, we save current scene as a reference (e.g. if at a later stage we need to import CAD data that have the same orientation at the curent robot). Then we select the model and<span> </span></span><a href="http://www.coppeliarobotics.com/helpFiles/en/coordinateDialog.htm">modify its position/orientation</a><span><span> </span>appropriately. It is considered good practice to position the model (i.e. its base object) at X=0 and Y=0.</span></p>
<p><br/>現在，我們保護模型免受意外修改。我們選擇機器人中的所有可見對象，然後選擇"模型本體"如果點擊螢幕的連結，則會改為選擇機器人的基礎。這使我們可以通過暗助Shift鍵並點擊場景，選擇對象來選擇機器人中的可見對象。現在，我們將機器人置於正確的起始位置/方向。首先，我們將當前場景做為參考（例如，如果稍後需要在當前機器人上導入方向相同的CAD數據）。然後，我們選擇模型並適當修改其位置/方向。將模型（即其基礎對象）定位在X = 0和Y = 0處被認為是一種好習慣。<br/>現在我們進行模擬:由於默認情況下關節不受控制，因此機器人被限制。在上一階段添加關節時，我們以力/扭矩模式創建了關節，但其電動機或控制器已禁用（默認情況下）。</p>
<p><span>We now run the simulation: the robot will collapse, since the joints are not controlled by default. </span><a href="http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm#joints">When we added the joints in the previous stage</a><span>, we created joints in force/torque mode, but their motor or controller was disabled (by default). We can now adjust our joints to our requirements. In our case, we want a simple PID controller for each one of them. In the joint dynamic properties, we click<span> </span></span><strong>Motor enabled</strong><span><span> </span>and adjust the<span> </span></span><strong>maximum torque</strong><span>. We then click<span> </span></span><strong>Control loop enabled</strong><span><span> </span>and select<span> </span></span><strong>Position control (PID)</strong><span>. We now run the simulation again: the robot should hold its position. Try to switch the current physics engine to see if the behaviour is consistent across all supported physics engines. You can do this via the appropriate<span> </span></span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars">toolbar button</a><span>, or in the<span> </span></span><a href="http://www.coppeliarobotics.com/helpFiles/en/dynamicsDialog.htm">general dynamics properties</a><span>.</span></p>
<p>現在，我們可以根據需要調整關節。在我們的案例中，我們希望為每個控制器都提供一個簡單的PID控制器。在關節動態屬性中，點擊"啟用電機"並調整最大扭拒。然後點擊啟用控制環，選擇位置控制(PID)。現在我們再次運行:機器人應保持其位置。嘗試切換當前的物理引擎，以查看行為在所有受支持的物理引擎之間是否一致。您可以通過相應的工具欄按鈕或在常規動力學屬性中執行此操作。<br/>在仿真過程中，我們現在通過“動態內容可視化和驗證”工具欄按鈕來驗證場景動態內容。現在，將僅顯示物理引擎考慮的項目，並且該顯示使用顏色編碼。始終執行此操作非常重要，尤其是在動態模型無法按預期運行時，為了快速調試模型，尤其如此。同樣，在仿真過程中請始終查看場景層次：動態啟用的對象應在其名稱的右側顯示一個球形圖標。最後，我們需要準備機器人，以便我們可以輕鬆地將抓取並連接到它，或輕鬆地將機器人連接並移動到平台。可以透過兩種不同的方式將動態啟用的形狀附加:</p>
<p>by grouping them: select the shapes, then [Menu bar --&gt; Edit --&gt; Grouping/Merging --&gt; Group selected shapes].<br/>通過對它們進行分組：選擇形狀，然後選擇[標題-&gt;編輯-&gt;分組/合併-&gt;對選定形狀進行分組]。</p>
<p>by attaching them via a force/torque sensor: a force torque sensor can also act as a rigid link between two separate dynamically enabled shapes.<br/>通過扭矩感測器進行連接:扭拒感測器可以當作兩個單獨的動態啟用形狀之間的剛性鏈結</p>
<h2>40723144</h2>
<p>現在，我們可以進一步細化/簡化單個形狀。有時，<br/>如果改用凸包，形狀可能會看起來更好。有時，您將<br/>不得不反複使用上述幾種技術，以獲得所需的結果。<br/>以以下網格為例：<br/>上面形狀的問題是，由於其中包含孔，我們無法很好<br/>地簡化它。因此，我們必須通過形狀編輯模式進行更<br/>複雜的處理，在該模式下，我們可以提取同一凸形子<br/>實體的單個元素。此過程可能需要進行多次迭代：我<br/>們首先提取3個近似凸元素。現在，我們忽略作為兩<br/>個孔的一部分的三角形。在形狀編輯模式下編輯形狀<br/>時，可以方便地切換可見性圖層，以查看其他場景項<br/>所覆蓋的內容。<br/>我們最終得到三個形狀的總和，但是其中兩個將需要<br/>進一步改進。現在我們可以擦除作為孔的一部分的三<br/>角形。最後，我們分別提取3種形狀的凸包，然後將<br/>其與[菜單欄-&amp;gt;編輯-&amp;gt;分組/合併-&amp;gt;合併所選形狀]合併<br/>在一起：<br/>在CoppeliaSim中，我們可以啟用/禁用每種形狀的邊<br/>緣顯示。我們還可以指定邊緣顯示時要考慮的角度。<br/>相似的參數是陰影角，它指示形狀將在多方面顯示。<br/>這些參數以及其他一些參數（例如形狀顏色）可以在<br/>形狀屬性中進行調整。到目前為止，在本教程中，我<br/>們僅處理簡單的形狀：簡單的形狀具有一組視覺屬性<br/>（即一種顏色，一個陰影角度等）。如果合併兩個形<br/>狀，則結果將是一個簡單的形狀。您還可以對形狀進<br/>行分組，在這種情況下，每個形狀將保留其視覺屬性<br/>。<br/>在下一步中，我們可以合併邏輯上屬於一起的元素（<br/>如果它們屬於同一剛性元素，並且具有相同的視覺屬</p>
<p>性）。然後，我們更改各種元素的視覺屬性。調整具<br/>有不同顏色和視覺屬性的幾種形狀的最簡便方法，如<br/>果我們使用特定的字符串來命名顏色，則以後可以輕<br/>鬆地以編程方式更改該顏色，即使該形狀是複合形狀<br/>的一部分。然後，我們選擇所有具有相同視覺屬性的<br/>形狀，然後控制選擇已調整的形狀，然後單擊“應用<br/>於選擇”，一次是“顏色”，一次是其他屬性，在形<br/>狀屬性中：這將轉移所有所選形狀的視覺屬性（如果<br/>提供的話，還包括顏色名稱）。我們最終得到17個<br/>單獨的形狀：<br/>現在，我們可以使用[菜單欄-&amp;gt;編輯-&amp;gt;分組/合併-&amp;gt;分<br/>組所選形狀]對屬於同一鏈接的形狀進行分組。我們<br/>最終得到7個形狀：機器人的基礎（或機器人的層次<br/>結構樹的基礎）和6個移動鏈接。正確命名對像也很<br/>重要：可以通過雙擊場景層次結構中的對象名稱來做<br/>到這一點。基礎是機械手或模型名稱，其他對象包含<br/>基礎對象名稱，例如：robot（基礎<br/>），robot_link1，robot_proximitySensor等。通過默<br/>認，形狀將分配給可見性層1，但可以在對象通用屬<br/>性中進行更改。默認情況下，僅激活場景的可見性層<br/>1-8。現在，我們有了以下內容（模型<br/>ResizableFloor_5_25模型在模型屬性對話框中暫時<br/>不可見）：<br/>創建或修改形狀時，CoppeliaSim將自動設置其參考<br/>框架的位置和方向。形狀的參考框架將始終位於形狀<br/>的幾何中心。將選擇框架方向，以便形狀的邊界框保<br/>持盡可能小。這並不總是看起來不錯，但是我們隨時<br/>可以隨時調整形狀的參考框架的方向。現在，我們可<br/>以使用[菜單欄-&amp;gt;編輯-&amp;gt;重定向邊界框-&amp;gt;使用世界參考</p>
<p>框架]重新調整所有已創建形狀的參考框架。您有更<br/>多選項可以在形狀幾何對話框中重新定向參考框架。</p>
<h2>40523241</h2>
<p><span style="font-weight: 400;">建立一個可見形體</span></p>
<p><span style="font-weight: 400;">每當建立一個新的模型，首先處理可見的外形:動態方面(底層有更多簡單優化的模型)，接頭，感測器…等等。將會在後面的段落一一介紹。</span></p>
<p></p>
<p><span style="font-weight: 400;">現在很快地可以從CoppeliaSim的路徑中[工具列🡪新增🡪基本形狀🡪…]建造一個基本形狀。做了這個步驟之後，可以建立單純的形狀或規則的形狀，單純的形體能在動態互動中更完善，也能夠確切不斷的變化(掉落，碰撞，但是在後面的段落中這是有缺陷的)，基本形狀會有簡單的網格，或許在這軟體中沒有包含足夠的細節或準確的幾何形狀。可以從其他的軟體輸入網格。</span></p>
<p><span style="font-weight: 400;">當從其他軟體輸入CAD檔，重點是在CAD檔的準確性是不嚴格的，即不包含太多三角網格。這項要求很重要，因為巨大模型的顯示速度會很慢，並且還會減慢以後可能使用的各種計算模塊（例如最小距離計算或動力學）。以下示例通常是不成功的（即使我們會在後面看到，即使有方法可以簡化CoppeliaSim中的數據）:</span></p>
<p></p>
<p><span style="font-weight: 400;">上面的CAD數據非常重要：它包含許多三角網格（超過47'000個），如果我們只在新的場景中使用單個三角網格的實例，這是可以的。但是大多數時候，您將需要模擬同一機器人的多個實例，連接各種類型的抓手，並可能使這些機器人與其他機器人，設備或環境進行交互。在這種情況下，模擬場景可能很快變得太慢。通常，我們建議對不超過2萬個三角形的機器人進行建模，但是在大多數情況下，5 000至10 000個三角網格也可以。記住：在幾乎所有方面，少即是好。</span></p>
<p></p>
<p><span style="font-weight: 400;">是什麼使上述模型如此重要？首先，包含孔和小細節的模型將需要更多的三角形面才能正確表示。因此，如果可能，請嘗試從原始模型數據中刪除所有的孔，螺釘，物體的內部等。如果您將原始模型數據表示為參數化曲面/對象，則通常在大多數情況下只需選擇並刪除它們即可（例如在Solidworks中）。第二個重要步驟是以有限的精度導出原始數據：大多數CAD應用程序都允許您指定導出的網格的細節級別。當工程圖由大小對象組成時，分幾步導出對象可能也很重要。這是為了避免大對象定義太精確（三角形太多）和小對象定義太粗（三角形太少）：首先簡單地導出大對象（通過調整所需的精度設置），然後導出小對象（通過調整精度設置） ）。</span></p>
<p></p>
<p><span style="font-weight: 400;">CoppeliaSim當前支持以下CAD數據格式：OBJ，STL，DXF，3DS（僅Windows）和Collada。還支持URDF，但此處未提及，因為它不是基於純網格的文件格式。</span></p>
<p></p>
<p><span style="font-weight: 400;">現在，假設我們已按照上一節中所述應用了所有可能的簡化。導入後，我們可能最終仍然會留下一個沉重的網格：</span></p>
<p></p>
<p><span style="font-weight: 400;">您會注意到整個機器人是作為單個網格導入的。稍後我們將看到如何對其進行適當劃分。還要注意導入的網格的方向錯誤：最好保持其方向不變，直到構建整個模型為止，因為如果在以後的階段中我們要導入與同一機器人相關的其他項目，它們將自動具有相對於原始網格的正確位置/方向。</span></p>
<p></p>
<p><span style="font-weight: 400;">在此階段，我們可以使用多種功能來簡化網格：</span></p>
<p></p>
<p><span style="font-weight: 400;">自動網格劃分：允許為未通過公共邊鏈接在一起的所有元素生成新形狀。這並不總是適用於選定的網格，但是總是值得一試的，因為與必須同時處理所有元素相比，處理網格元素可以為我們提供更多的控制權。可以通過[菜單欄-&gt;編輯-&gt;分組/合併-&gt;分割所選形狀]訪問該功能。有時，網格劃分會超出預期。在這種情況下，只需將邏輯上屬於一起的元素（即，具有相同的視覺屬性並且屬於同一鏈接的一部分）合併回一個單一形狀（[菜單欄-&gt;編輯-&gt;分組/合併-&gt;合併選定的形狀]）。</span></p>
<p><span style="font-weight: 400;">提取凸面形體：通過將其轉換為凸面形體來簡化網格。可以通過[菜單欄-&gt;編輯-&gt;將選擇變形為凸形]來訪問該功能。</span></p>
<p><span style="font-weight: 400;">抽取網格：減少網格中包含的三角形數量。可以通過[菜單欄-&gt;編輯-&gt;縮小所選形狀...]訪問該功能。</span></p>
<p><span style="font-weight: 400;">刪除網格的內部：允許通過刪除其內部來簡化網格。此功能基於視覺傳感器，根據所選設置可能會或多或少地令人滿意。可以通過[菜單欄-&gt;編輯-&gt;提取選定形狀的內部]訪問該功能。</span></p>
<p><span style="font-weight: 400;">沒有/可以應用上述功能的預定義順序（列表中的第一項除外，應始終首先嘗試該項），它在很大程度上取決於我們要簡化的網格的幾何形狀。下圖說明了應用於導入的網格的上述功能（假設列表中的第一項對我們不起作用）：</span></p>
<p></p>
<p><span style="font-weight: 400;">請注意，凸面形體在現階段如何對我們沒有幫助。我們決定首先使用網格抽取功能，然後運行兩次該功能，以將三角網格的數量總共除以50。完成後，我們提取簡化形狀的內部並將其丟棄。我們最終得到的網格總共包含2'660個三角形（原始導入的網格包含了136'000個三角網格！）。形狀包含的三角網格/頂點的數量可以在形狀幾何對話框中看到。對於整個機器人模型，2'660三角網格是極少的三角形，因此視覺外觀可能會因此受到影響。</span></p>
<p></p>
<p><span style="font-weight: 400;">在這一階段，我們可以開始將機器人劃分為單獨的鏈接（請記住，我們目前整個機器人只有一個形狀）。您可以通過兩種不同的方式執行此操作：</span></p>
<p></p>
<p><span style="font-weight: 400;">自動網格劃分：此功能已在上一節中進行了描述，它將檢查形狀並為未通過公共邊鏈接在一起的所有元素生成新形狀。這並不總是有效，但總是值得嘗試的。可以通過[菜單欄-&gt;編輯-&gt;分組/合併-&gt;分割所選形狀]訪問該功能。</span></p>
<p><span style="font-weight: 400;">手動網格劃分：通過三角網格編輯模式，您可以手動選擇邏輯上不屬於邏輯的三角網格，然後單擊“提取形狀”。這將在場景中生成新形狀。完成該操作後，刪除選定的三角網格。</span></p>
<p><span style="font-weight: 400;">對於我們的網格，方法1可以正常工作：</span></p>
<p></p>
<p><span style="font-weight: 400;">Build the visible shape</span></p>
<p><span style="font-weight: 400;">When building a new model, first, we handle only the visual aspect of it: the dynamic aspect (its undelying even more simplified/optimized model), joints, sensors, etc. will be handled at a later stage.</span></p>
<p><span style="font-weight: 400;">We could now directly create primitive shapes in CoppeliaSim with [Menu bar --&gt; Add --&gt; Primitive shape --&gt; ...]. When doing this, we have the option to create </span><a href="http://www.coppeliarobotics.com/helpFiles/en/shapes.htm"><span style="font-weight: 400;">pure shapes, or regular shapes</span></a><span style="font-weight: 400;">. Pure shape will be optimized for dynamic interaction, and also directly be dynamically enabled (i.e. fall, collide, but this can be disabled at a later stage). Primitive shapes will be simple meshes, which might not contain enough details or geometric accuracy for our application. Our other option in that case would be to import a mesh from an external application.</span></p>
<p><span style="font-weight: 400;">When importing CAD data from an external application, the most important is to make sure that the CAD model is not too heavy, i.e. doesn't contain too many triangles. This requirement is important since a heavy model will be slow in display, and also slow down various calculation modules that might be used at a later stage (e.g. </span><a href="http://www.coppeliarobotics.com/helpFiles/en/distanceCalculation.htm"><span style="font-weight: 400;">minimum distance calculation</span></a><span style="font-weight: 400;">, or </span><a href="http://www.coppeliarobotics.com/helpFiles/en/dynamicsModule.htm"><span style="font-weight: 400;">dynamics</span></a><span style="font-weight: 400;">). Following example is typically a no-go (even if, as we will see later, there are means to simplify the data within CoppeliaSim):</span></p>
<p></p>
<p><span style="font-weight: 400;">Above CAD data is very heavy: it contains many triangles (more than 47'000), which would be ok if we would just use a single instance of it in an empty scene. But most of the time you will want to simulate several instances of a same robot, attach various types of grippers, and maybe have those robots interact with other robots, devices, or the environment. In that case, a simulation scene can quickly become too slow. Generally, we recommend to model a robot with no more than a total of 20'000 triangles, but most of the time 5'000-10'000 triangles would just do fine as well. Remember: less is better, in almost every aspect.</span></p>
<p><span style="font-weight: 400;">What makes above model so heavy? First, models that contain holes and small details will require much more triangular faces for a correct representation. So, if possible, try to remove all the holes, screws, the inside of objects, etc. from your original model data. If you have the original model data represented as parametric surfaces/objects, then it is most of the time a simple matter of selecting the items and deleting them (e.g. in Solidworks). The second important step is to export the original data with a limited precision: most CAD applications let you specify the level of details of exported meshes. It might also be important to export the objects in several steps, when the drawing consists of large and small objects; this is to avoid having large objects too precisely defined (too many triangles) and small objects too roughly defined (too few triangles): simply export large objects first (by adjusting the desired precision settings), then small objects (by adjusting up precision settings).</span></p>
<p><span style="font-weight: 400;">CoppeliaSim supports currently following CAD data formats: </span><a href="http://www.coppeliarobotics.com/helpFiles/en/importExport.htm"><span style="font-weight: 400;">OBJ</span></a><span style="font-weight: 400;">, </span><a href="http://www.coppeliarobotics.com/helpFiles/en/importExport.htm"><span style="font-weight: 400;">STL</span></a><span style="font-weight: 400;">, </span><a href="http://www.coppeliarobotics.com/helpFiles/en/importExport.htm"><span style="font-weight: 400;">DXF</span></a><span style="font-weight: 400;">, </span><a href="http://www.coppeliarobotics.com/helpFiles/en/importExport.htm"><span style="font-weight: 400;">3DS</span></a><span style="font-weight: 400;"> (Windows only), and </span><a href="http://www.coppeliarobotics.com/helpFiles/en/colladaPlugin.htm"><span style="font-weight: 400;">Collada</span></a><span style="font-weight: 400;">. </span><a href="http://www.coppeliarobotics.com/helpFiles/en/urdfPlugin.htm"><span style="font-weight: 400;">URDF</span></a><span style="font-weight: 400;"> is also supported, but not mentionned here since it is not a pure mesh-based file format.</span></p>
<p><span style="font-weight: 400;">Now suppose that we have applied all possible simplifications as described in previous section. We might still end-up with a too heavy mesh after import:</span></p>
<p></p>
<p><span style="font-weight: 400;">You can notice that the whole robot was imported as a single mesh. We will see later how to divide it appropriately. Notice also the wrong orientation of the imported mesh: best is to keep the orientation as it is, until the whole model was built, since, if at a later stage we want to import other items that are related to that same robot, they will automatically have the correct position/orientation relative to the original mesh.</span></p>
<p><span style="font-weight: 400;">At this stage, we have several functions at our disposal, to simplify the mesh:</span></p>
<p><span style="font-weight: 400;">  </span><b>Automatic mesh division:</b><span style="font-weight: 400;"> allows to generate a new shape for all elements that are not linked together via a common edge. This does not always work for the selected mesh, but is always worth a try, since working on mesh elements gives us more control than if we had to work on all elements at the same time. The function can be accessed with [Menu bar --&gt; Edit --&gt; Grouping/Merging --&gt; Divide selected shapes]. Sometimes, a mesh will be divided more than expected. In that case, simply merge elements that logically belong together (i.e. that will have the same visual attributes and that are part of the same link) back into one single shape ([Menu bar --&gt; Edit -&gt; Grouping/Merging --&gt; Merge selected shapes]).</span></p>
<p><span style="font-weight: 400;">  </span><b>Extract the convex hull:</b><span style="font-weight: 400;"> allows to simplify the mesh by transforming it into a convex hull. The function can be accessed with [Menu bar --&gt; Edit --&gt; Morph selection into convex shapes].</span></p>
<p><span style="font-weight: 400;">  </span><b>Decimate the mesh:</b><span style="font-weight: 400;"> allows to reduce the number of triangles contained in the mesh. The function can be accessed with [Menu bar --&gt; Edit --&gt; Decimate selected shape...].</span></p>
<p><span style="font-weight: 400;">  </span><b>Remove the inside of the mesh:</b><span style="font-weight: 400;"> allows to simplify the mesh by removing its inside. This function is based on </span><a href="http://www.coppeliarobotics.com/helpFiles/en/visionSensors.htm"><span style="font-weight: 400;">vision sensors</span></a><span style="font-weight: 400;"> and might give more or less satisfying results depending on the selected settings. The function can be accessed with [Menu bar --&gt; Edit --&gt; Extract inside of selected shape].</span></p>
<p><span style="font-weight: 400;">There is no predefined order in which above functions can/should be applied (except for the first item in the list, which should always be tried first), it heavily depends on the geometry of the mesh we are trying to simplify. Following image illustrates above functions applied to the imported mesh (let's suppose the first item in the list didn't work for us):</span></p>
<p><span style="font-weight: 400;">Notice how the convex hull doesn't help us at this stage. We decide to use the mesh decimation function first, and run the function twice in order to divide the number of triangles by a total of 50. Once that is done, we extract the inside of the simplified shape and discard it. We end-up with a mesh containing a total of 2'660 triangles (the original imported mesh contained more than 136'000 triangles!). The number of triangles/vertices a shape contains can be seen in the </span><a href="http://www.coppeliarobotics.com/helpFiles/en/geometryDialog.htm"><span style="font-weight: 400;">shape geometry dialog</span></a><span style="font-weight: 400;">. 2'660 triangles are extremely few triangles for a whole robot model, and the visual appearance might suffer a little bit from it.</span></p>
<p><span style="font-weight: 400;">At this stage we can start to divide the robot into separate links (remember, we currently have only a single shape for the whole robot). You can do this in two different ways:</span></p>
<p><span style="font-weight: 400;">  </span><b>Automatic mesh division:</b><span style="font-weight: 400;"> this function, which was already described in previous section, will inspect the shape and generate a new shape for all elements that are not linked together via a common edge. This does not always work, but is always worth a try. The function can be accessed with [Menu bar --&gt; Edit --&gt; Grouping/merging --&gt; Divide selected shapes].</span></p>
<p><span style="font-weight: 400;">  </span><b>Manual mesh division:</b><span style="font-weight: 400;"> via the the </span><a href="http://www.coppeliarobotics.com/helpFiles/en/triangleEditMode.htm"><span style="font-weight: 400;">triangle edit mode</span></a><span style="font-weight: 400;">, you can manually select the triangles than logically belong together, then click </span><b>Extract shape</b><span style="font-weight: 400;">. This will generate a new shape in the scene. Delete the selected triangles after that operation.</span></p>
<p><span style="font-weight: 400;">In the case of our mesh, method 1 worked fine:</span></p>
<p></p>